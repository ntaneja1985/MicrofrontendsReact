# Microfrontends in React
- Consider an ecommerce application
- ![img.png](img.png)
- ![img_1.png](img_1.png)
- To turn it into micro-frontend application
- Identify the major features
- ![img_2.png](img_2.png)
- Split it into 2 applications
- ![img_3.png](img_3.png)
- ![img_4.png](img_4.png)
- ![img_5.png](img_5.png)
- ![img_7.png](img_7.png)
- We could have 2 separate teams to develop each of the applications
- ![img_8.png](img_8.png)

## Application Overview
- We will make an ecommerce store
- ![img_9.png](img_9.png)
- If we were making a monolithic app it will look like this
- ![img_10.png](img_10.png)
- If we make a micro-frontend it will look like this:
- ![img_11.png](img_11.png)
- How do we decide where to show each of these microfrontends on the screen
- So we can create a container app
- This container app decides when and where to show each micro-frontend
- ![img_12.png](img_12.png)

### Understanding Build-time integration
- ![img_13.png](img_13.png)
- ![img_14.png](img_14.png)
- ![img_15.png](img_15.png)
- ![img_16.png](img_16.png)
- It is easy to set up and understand. However, container has to be re-deployed everytime ProductsList is updated
- It is tempting to couple the container and ProductsList together.

### Understanding the Run-time integration
- ![img_17.png](img_17.png)
- Advantage of this approach is ProductsList can be deployed independently at any time
- Also, different versions of ProductsList can be deployed and Container can decide which one to use
- However, tooling and setup is far more complicated.
- ![img_18.png](img_18.png)
- Run-time integration with Webpack module integration is usually the best approach

### Project Setup with Run-time integration
- We will create separate folders for each of our front-ends
- ![img_19.png](img_19.png)
- ![img_20.png](img_20.png)

### Understanding Webpack
- ![img_21.png](img_21.png)
- Initially we used the fakers library to create a list of products in index.js as follows
```js
import faker from 'faker';
let products = '';
for(let i=0; i<3; i++){
    const name = faker.commerce.productName(i);
    products += `<div>${name}</div>`;
}

console.log(products);
```
- Now we created a webpack.config.js file and added the following code to it
```js
module.exports = {
    mode: "development",
};
```
- Then we went to package.json and in the scripts section added: "start":"webpack"
- When we ran npm run start, it created a dist folder which had a main.js file
- ![img_23.png](img_23.png)
- Basically, Webpack is used to combine many JS files into a single JS file
- ![img_22.png](img_22.png)
- When we load up our project in the browser, we dont want to load up a bunch of different files
- Thats where Webpack comes into play.
- It combines several JS files into a single file.
- main.js or bundle.js file is the output of webpack, it even includes the JS files of the dependencies we had included as well.
- In the above example, it included code for the faker library also
- We want to execute the main.js file in the browser and generate HTML
- So we need a webpack Dev Server
- ![img_24.png](img_24.png)
- For this, we just need to make a small change in the webpack.config.js file
```js
module.exports = {
    mode: "development",
    devServer: {
        port: 8081,
    }
};

```
- Then we create an index.html page for Products
- Rather than explicitly referencing main.js file generated by webpack be added within script tags in the page, we will have Webpack figure it out for us
- Files generated by webpack have unpredictable names
- ![img_25.png](img_25.png)
- So we will use webpack html plugin
- It will take a look at files coming out of webpack and automatically insert it into the HTML document
- ![img_26.png](img_26.png)
- Make following changes to webpack.config.js file
```js
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
    mode: "development",
    devServer: {
        port: 8081,
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './public/index.html',
        })
    ]
};
```
- When we now run npm run start, it will start up the server and show contents of what we have logged
- ![img_27.png](img_27.png)
- if we update index.js, it is automatically picked up by webpack and content inside the browser is automatically refreshed.

### Scaffolding the Container
- We will do the exact same steps as we did for Product earlier and have an empty HTML page, add the webpack.config.js files and add an index.js file which is as follows
```js
console.log('Container');
```
- We will also have a webpack.config.js file
```js
const HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
    mode: 'development',
    devServer: {
        port: 8080,
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './public/index.html',
        })
    ]
}
```

## Basics of Module Federation
- Now we need to set up our integration process.
- We need to call Products from the Container
- ![img_29.png](img_29.png)
- For this go to the products folder and inside its webpack.config.js add the following code
```js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');
module.exports = {
    mode: "development",
    devServer: {
        port: 8081,
    },
    plugins: [
        new ModuleFederationPlugin({
            name: 'products',
            filename: 'remoteEntry.js',
            exposes:{
                './ProductsIndex':'./src/index'
            }
        }),
        new HtmlWebpackPlugin({
            template: './public/index.html',
        })
    ]
};
```
- Note that remoteEntry.js specifies the various modules that can be loaded from the Products project
- Further, in the webpack.config.js file of the container application, we have this code:
```js
const HtmlWebpackPlugin = require("html-webpack-plugin");
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");
module.exports = {
    mode: 'development',
    devServer: {
        port: 8080,
    },
    plugins: [
        new ModuleFederationPlugin({
            name: 'container',
            remotes:{
                products : 'products@http://localhost:8081/remoteEntry.js'
            }
        }),
        new HtmlWebpackPlugin({
            template: './public/index.html',
        })
    ]
}
```
- This code looks mysterious at first
- Notice that when we run the products code(running on localhost:8081) from container project(localhost:8080), we can go to network tab and see this
- ![img_30.png](img_30.png)
- Notice that 3 files are coming from localhost:8081
- We can explain this process with the following diagram:
- ![img_31.png](img_31.png)
- Think of remoteEntry.js file as a sort of directions for other projects. 
- These directions tell the container how to load source code from the products project
- The src/index.js contains the actual code exposed by the products project
- Micro-frontends in React using the Module Federation Plugin (part of Webpack 5) allow you to break a large React application into smaller, independently deployable modules. 
- Each module can be developed, tested, and deployed separately, yet they integrate seamlessly at runtime. This approach improves scalability, team autonomy, and code maintainability.
- Module Federation enables a JavaScript application to dynamically load code from another application or module at runtime.
- Each micro-frontend is a standalone app with its own build process, but they share dependencies and expose components or modules to one another.
- A host application loads remote modules (exposed by other apps) using Webpack's configuration.
- Real-World Examples
- E-commerce Platform: A retail site splits its UI into micro-frontends:
- Product catalog (React app)
- Shopping cart (React app)
- User authentication (React app) Each team works independently, deploying updates without affecting others. 
- The cart module can be reused across the main site and mobile app.

### Understanding how Module Federation Plugin works in Container Application
- ![img_32.png](img_32.png)
- Why do we need index.js file inside container application? Especially when all it contains is import('./bootstrap')
- This basically is because Webpack knows that it is has to fetch something from products before running this file
- 
- The bootstrap.js file contains:
```js
import 'products/ProductsIndex';

console.log('Container');
```
- Overall the big picture looks like this:
- ![img_33.png](img_33.png)
- This can further be explained by this
- ![img_34.png](img_34.png)

### Understanding Configuration Options inside the Module Federation Plugin
- ![img_35.png](img_35.png)
- Notice that inside bootstrap.js we have:
```js
import 'products/ProductsIndex';

console.log('Container');
```
- This basically looks for 'products' inside the remotes section of the Module Federation Plugin inside webpack.config.js file of the container application
- There we can find the location of products list(in this case: localhost:8081/remoteEntry.js)
- ![img_36.png](img_36.png)
- We can have multiple modules or components or files inside the Products application
- We can choose what to expose to the outside containers
- Another example is this
- ![img_37.png](img_37.png)
- Let's just say we just want barchart
- We can specify that as following in the Container
- ![img_38.png](img_38.png)

### Scaffolding the Cart
- ![img_39.png](img_39.png)
- We will do the same exact steps as product
- Add a package.json and install all the dependencies(same as product)
- Next, add an index.js and add the following code to it
```js
import faker from "faker";

const cartText = `<div>You have ${faker.random.number()} 
                        items in your cart</div>`

document.querySelector("#dev-cart").innerHTML = cartText;
```
- Next add an index.html with the following code:
```html
<!DOCTYPE html>
<html>
<head>

</head>
<body>
<div id="dev-cart"></div>
</body>
</html>
```
- Next add a webpack.config.js and expose the cart Index page
```js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');

module.exports = {
    mode: 'development',
    devServer: {
        port: 8082,
    },
    plugins: [
        new ModuleFederationPlugin({
            name: 'cart',
            filename: 'remoteEntry.js',
            exposes:{
                './CartShow':'./src/index'
            }
        }),
        new HtmlWebpackPlugin({
            template: './public/index.html'
        })
    ]
}
```
- If we just run the cart in isolation we get this:
- ![img_40.png](img_40.png)

### Cart Integration
- First modify the webpack.config.js file of container application as follows:
```js
const HtmlWebpackPlugin = require("html-webpack-plugin");
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");
module.exports = {
    mode: 'development',
    devServer: {
        port: 8080,
    },
    plugins: [
        new ModuleFederationPlugin({
            name: 'container',
            remotes:{
                products : 'products@http://localhost:8081/remoteEntry.js',
                cart:'cart@http://localhost:8082/remoteEntry.js',
            }
        }),
        new HtmlWebpackPlugin({
            template: './public/index.html',
        })
    ]
}
```
- Next add the cart import to boostrap:
```js
import 'products/ProductsIndex';
import 'cart/CartShow'

console.log('Container');
```
- Next add a div with id of dev-cart inside the index.html file of the container app
```html

<!DOCTYPE html>
<html>
<head></head>
<body>
<div id="dev-products"></div>
<div id="dev-cart"></div>
</body>
</html>
```
- Finally, when we run it, we can see this
- ![img_41.png](img_41.png)
- Notice that we can see items in the cart alongside the products list

### What the development process looks like while using Micro-frontends
- ![img_42.png](img_42.png)
- Notice the role of the html files
- ![img_43.png](img_43.png)
- We only use HTML files from the container application in Production
- HTML files from products and cart are only for testing in development process

## Sharing Dependencies Between Apps

