# Microfrontends in React
- Consider an ecommerce application
- ![img.png](img.png)
- ![img_1.png](img_1.png)
- To turn it into micro-frontend application
- Identify the major features
- ![img_2.png](img_2.png)
- Split it into 2 applications
- ![img_3.png](img_3.png)
- ![img_4.png](img_4.png)
- ![img_5.png](img_5.png)
- ![img_7.png](img_7.png)
- We could have 2 separate teams to develop each of the applications
- ![img_8.png](img_8.png)

## Application Overview
- We will make an ecommerce store
- ![img_9.png](img_9.png)
- If we were making a monolithic app it will look like this
- ![img_10.png](img_10.png)
- If we make a micro-frontend it will look like this:
- ![img_11.png](img_11.png)
- How do we decide where to show each of these microfrontends on the screen
- So we can create a container app
- This container app decides when and where to show each micro-frontend
- ![img_12.png](img_12.png)

### Understanding Build-time integration
- ![img_13.png](img_13.png)
- ![img_14.png](img_14.png)
- ![img_15.png](img_15.png)
- ![img_16.png](img_16.png)
- It is easy to set up and understand. However, container has to be re-deployed everytime ProductsList is updated
- It is tempting to couple the container and ProductsList together.

### Understanding the Run-time integration
- ![img_17.png](img_17.png)
- Advantage of this approach is ProductsList can be deployed independently at any time
- Also, different versions of ProductsList can be deployed and Container can decide which one to use
- However, tooling and setup is far more complicated.
- ![img_18.png](img_18.png)
- Run-time integration with Webpack module integration is usually the best approach

### Project Setup with Run-time integration
- We will create separate folders for each of our front-ends
- ![img_19.png](img_19.png)
- ![img_20.png](img_20.png)

### Understanding Webpack
- ![img_21.png](img_21.png)
- Initially we used the fakers library to create a list of products in index.js as follows
```js
import faker from 'faker';
let products = '';
for(let i=0; i<3; i++){
    const name = faker.commerce.productName(i);
    products += `<div>${name}</div>`;
}

console.log(products);
```
- Now we created a webpack.config.js file and added the following code to it
```js
module.exports = {
    mode: "development",
};
```
- Then we went to package.json and in the scripts section added: "start":"webpack"
- When we ran npm run start, it created a dist folder which had a main.js file
- ![img_23.png](img_23.png)
- Basically, Webpack is used to combine many JS files into a single JS file
- ![img_22.png](img_22.png)
- When we load up our project in the browser, we dont want to load up a bunch of different files
- Thats where Webpack comes into play.
- It combines several JS files into a single file.
- main.js or bundle.js file is the output of webpack, it even includes the JS files of the dependencies we had included as well.
- In the above example, it included code for the faker library also
- We want to execute the main.js file in the browser and generate HTML
- So we need a webpack Dev Server
- ![img_24.png](img_24.png)
- For this, we just need to make a small change in the webpack.config.js file
```js
module.exports = {
    mode: "development",
    devServer: {
        port: 8081,
    }
};

```
- Then we create an index.html page for Products
- Rather than explicitly referencing main.js file generated by webpack be added within script tags in the page, we will have Webpack figure it out for us
- Files generated by webpack have unpredictable names
- ![img_25.png](img_25.png)
- So we will use webpack html plugin
- It will take a look at files coming out of webpack and automatically insert it into the HTML document
- ![img_26.png](img_26.png)
- Make following changes to webpack.config.js file
```js
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
    mode: "development",
    devServer: {
        port: 8081,
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './public/index.html',
        })
    ]
};
```
- When we now run npm run start, it will start up the server and show contents of what we have logged
- ![img_27.png](img_27.png)
- if we update index.js, it is automatically picked up by webpack and content inside the browser is automatically refreshed.

### Scaffolding the Container
- We will do the exact same steps as we did for Product earlier and have an empty HTML page, add the webpack.config.js files and add an index.js file which is as follows
```js
console.log('Container');
```
- We will also have a webpack.config.js file
```js
const HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
    mode: 'development',
    devServer: {
        port: 8080,
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './public/index.html',
        })
    ]
}
```

## Basics of Module Federation
